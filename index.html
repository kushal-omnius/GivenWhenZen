<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Free online Gherkin editor with real-time formatting, validation, and linting. Perfect for BDD (Behavior Driven Development) with Cucumber, JBehave, and SpecFlow.">
    <meta name="keywords" content="Gherkin, Cucumber, BDD, Behavior Driven Development, JBehave, SpecFlow, Feature Files, Given When Then, Scenario Outline, Test Automation, Acceptance Testing, ATDD">
    <meta name="author" content="GivenWhenZen">
    <meta property="og:title" content="GivenWhenZen - Online Gherkin Editor & Validator">
    <meta property="og:description" content="Free online Gherkin editor for BDD practitioners. Format, validate, and lint your feature files in real-time.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="GivenWhenZen - Gherkin Editor & BDD Tool">
    <meta name="twitter:description" content="Free online Gherkin editor for Cucumber, JBehave, and SpecFlow. Perfect for BDD practitioners.">
    <title>GivenWhenZen - Online Gherkin Editor, Formatter & BDD Tool</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="canonical" href="https://givenwhenzen.kushalbhalaik.xyz">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <link rel="alternate" hreflang="en" href="https://givenwhenzen.kushalbhalaik.xyz">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "GivenWhenZen - Online Gherkin Editor",
      "url": "https://givenwhenzen.kushalbhalaik.xyz",
      "applicationCategory": "DeveloperApplication",
      "operatingSystem": "All",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "Free online Gherkin editor with real-time formatting, validation, and linting for BDD (Behavior Driven Development). Compatible with Cucumber, JBehave, and SpecFlow.",
      "browserRequirements": "Requires a modern web browser",
      "softwareVersion": "1.0.0",
      "keywords": "Gherkin, Cucumber, BDD, Behavior Driven Development, JBehave, SpecFlow, Feature Files",
      "creator": {
        "@type": "Person",
        "name": "Kushal Bhalaik"
      }
    }
    </script>

    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/gherkin/gherkin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/lint.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.7/beautify.min.js"></script>
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/cobalt.min.css">
    
    <!-- Add Lint CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/lint.css">
    
    <!-- Main CSS -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="banner">
        <div class="banner-left">
            <a href="/" class="logo" title="Go to Homepage">
                <img src="favicon.png" alt="GivenWhenZen Logo">
                <span class="logo-text">{ GivenWhenZen }</span>
            </a>
            <span class="subtitle">Online Gherkin Editor and Formatter</span>
        </div>
        <div class="banner-right">
            <button class="theme-toggle" title="Switch to zen theme">‚òÄÔ∏è</button>
        </div>
    </div>
    <div class="editor-container">
        <h3>Format, validate and lint your Gherkin feature files, just paste it below:</h3>
        <textarea id="editor"></textarea>
    </div>
    <div class="button-container">
        <button onclick="formatEditor()" class="action-button format-button" data-shortcut="(Ctrl+Shift+F)">Format</button>
        <button onclick="clearEditor()" class="action-button clear-button" data-shortcut="(Ctrl+D)">Clear</button>
        <button onclick="copyToClipboard()" class="action-button copy-button" disabled>Copy to clipboard</button>
    </div>
    <div class="bottom">
        <div class="shortcuts">
            <h2>Shortcuts:</h2>
            <ul>
                <li>Format: Ctrl+Shift+F (Windows) / Cmd+Shift+F (Mac)</li>
                <li>Clear: Ctrl+D (Windows) / Cmd+D (Mac)</li>
            </ul>
        </div>
        <p>
            <a href="https://www.kushalbhalaik.xyz/" target="_blank" rel="noopener noreferrer">
                Made with <span class="love-emoji">üíô</span> in Berlin
            </a>
        </p>
        <p class="copyright">¬© 2025 GivenWhenZen.</p>
    </div>
    <script>
        // Global indentation configuration
        const INDENT_CONFIG = {
            TOP_LEVEL_KEYWORDS: 0,          // For Feature, Background, Scenario, Scenario outline, tags, etc.
            GIVEN: 2,        // For Given steps
            WHEN_THEN: 3,    // For When/Then steps
            AND_BUT: 4,      // For And/But/* steps
            TABLE: 6,        // For data tables
            EXAMPLES: 2,     // For Examples section
            DOC_STRING: 6,   // For doc strings
            COMMENT: 2,      // For comments
            NONE: 0,         // For nothing
        };

        // Function to format Gherkin code
        function formatGherkin(code) {
            const lines = code.split('\n');
            let inDocString = false;
            // Table block tracking
            let tableBlocks = [];
            let currentTable = null;

            // First pass: identify table blocks and calculate column widths per table
            lines.forEach((line, index) => {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('|')) {
                    if (!currentTable) {
                        currentTable = { start: index, end: index, rows: [] };
                    }
                    const cells = trimmedLine.split('|')
                        .map(cell => cell.trim())
                        .filter(cell => cell !== '');
                    currentTable.rows.push(cells);
                    currentTable.end = index;
                } else {
                    if (currentTable) {
                        tableBlocks.push(currentTable);
                        currentTable = null;
                    }
                }
            });
            if (currentTable) {
                tableBlocks.push(currentTable);
            }

            // For each table block, calculate max column widths
            tableBlocks.forEach(table => {
                table.maxColumnWidths = [];
                table.rows.forEach(row => {
                    row.forEach((cell, colIndex) => {
                        table.maxColumnWidths[colIndex] = Math.max(table.maxColumnWidths[colIndex] || 0, cell.length);
                    });
                });
            });

            // Second pass: format lines
            const formattedLines = [];
            let tableBlockIdx = 0;
            let insideTable = false;
            let currentTableBlock = null;
            for (let index = 0; index < lines.length; index++) {
                let line = lines[index];
                let formattedLine = line.trimRight(); // Keep trailing spaces

                // Handle empty lines
                if (!formattedLine.trim()) {
                    formattedLines.push('');
                    continue;
                }

                // TOP_LEVEL_KEYWORDS indentation
                if (
                    formattedLine.trim().startsWith('@') ||
                    formattedLine.trim().startsWith('Feature:') ||
                    formattedLine.trim().startsWith('As ') ||
                    formattedLine.trim().startsWith('I want ') ||
                    formattedLine.trim().startsWith('So that ')) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.TOP_LEVEL_KEYWORDS) + formattedLine.trim());
                    continue;
                }

                // Background and Scenario - TOP_LEVEL_KEYWORDS indentation
                if (formattedLine.trim().startsWith('Background:') ||
                    formattedLine.trim().startsWith('Scenario:') ||
                    formattedLine.trim().startsWith('Scenario Outline:')) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.TOP_LEVEL_KEYWORDS) + formattedLine.trim());
                    continue;
                }

                // Given steps
                if (formattedLine.match(/^\s*(Given)/)) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.GIVEN) + formattedLine.trim());
                    continue;
                }

                // When/Then steps
                if (formattedLine.match(/^\s*(When|Then)/)) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.WHEN_THEN) + formattedLine.trim());
                    continue;
                }

                // And/But/* steps
                if (formattedLine.match(/^\s*(And|But|\*)/)) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.AND_BUT) + formattedLine.trim());
                    continue;
                }

                // Tables - with vertical pipe alignment, per-table
                if (formattedLine.trim().startsWith('|')) {
                    // Find which table block this line belongs to
                    if (!insideTable) {
                        // Find the table block that starts at this line
                        for (let tb = tableBlockIdx; tb < tableBlocks.length; tb++) {
                            if (tableBlocks[tb].start <= index && tableBlocks[tb].end >= index) {
                                currentTableBlock = tableBlocks[tb];
                                tableBlockIdx = tb;
                                insideTable = true;
                                break;
                            }
                        }
                    }
                    const cells = formattedLine.trim().split('|')
                        .map(cell => cell.trim())
                        .filter(cell => cell !== '');
                    // Apply consistent padding based on current table's max column widths
                    const paddedCells = cells.map((cell, idx) => {
                        const width = currentTableBlock ? currentTableBlock.maxColumnWidths[idx] || 0 : cell.length;
                        return cell.padEnd(width, ' ');
                    });
                    formattedLines.push(' '.repeat(INDENT_CONFIG.TABLE) + '| ' + paddedCells.join(' | ') + ' |');
                    // If this is the last line of the table block, reset
                    if (currentTableBlock && index === currentTableBlock.end) {
                        insideTable = false;
                        currentTableBlock = null;
                        tableBlockIdx++;
                    }
                    continue;
                }

                // Doc strings
                if (formattedLine.trim().startsWith('"""')) {
                    inDocString = !inDocString; // Toggle doc string state
                    formattedLines.push(' '.repeat(INDENT_CONFIG.DOC_STRING) + formattedLine.trim());
                    continue;
                }
                // Content inside doc string
                if (inDocString) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.DOC_STRING) + formattedLine.trim());
                    continue;
                }

                // Comments
                if (formattedLine.trim().startsWith('#')) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.COMMENT) + formattedLine.trim());
                    continue;
                }

                // Examples section
                if (formattedLine.trim().startsWith('Examples:')) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.EXAMPLES) + formattedLine.trim());
                    continue;
                }

                formattedLines.push(formattedLine);
            }

            return formattedLines.join('\n');
        }

        // Gherkin Lint function
        CodeMirror.registerHelper("lint", "gherkin", function(text) {
            const found = [];
            const lines = text.split('\n');
            let inFeature = false;
            let inScenario = false;
            let lastStepType = null;
            let hasBackground = false;

            // Table block tracking for column count validation
            let tableBlocks = [];
            let currentTable = null;
            lines.forEach((line, index) => {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('|')) {
                    if (!currentTable) {
                        currentTable = { start: index, end: index, rows: [] };
                    }
                    const cells = trimmedLine.split('|')
                        .map(cell => cell.trim())
                        .filter(cell => cell !== '');
                    currentTable.rows.push({ cells, lineIndex: index });
                    currentTable.end = index;
                } else {
                    if (currentTable) {
                        tableBlocks.push(currentTable);
                        currentTable = null;
                    }
                }
            });
            if (currentTable) {
                tableBlocks.push(currentTable);
            }

            // Validate column count for each table block
            tableBlocks.forEach(table => {
                // Find expected column count (most common count or max count)
                const colCounts = table.rows.map(r => r.cells.length);
                // Use max count as expected
                const expectedColCount = Math.max(...colCounts);
                table.rows.forEach(row => {
                    if (row.cells.length !== expectedColCount) {
                        found.push({
                            from: CodeMirror.Pos(row.lineIndex, 0),
                            to: CodeMirror.Pos(row.lineIndex, lines[row.lineIndex].length),
                            message: `Table row has ${row.cells.length} columns, expected ${expectedColCount}.`,
                            severity: "error"
                        });
                    }
                });
            });

            lines.forEach((line, i) => {
                const trimmedLine = line.trim();
                // Track docstring state
                if (!lines._inDocString) lines._inDocString = false;
                if (trimmedLine.startsWith('"""')) {
                    lines._inDocString = !lines._inDocString;
                }

                // Check indentation
                if (trimmedLine) {
                    const indent = line.match(/^(\s*)/)[1].length;
                    let expectedIndent;
                    if (lines._inDocString && !trimmedLine.startsWith('"""')) {
                        expectedIndent = INDENT_CONFIG.DOC_STRING;
                    } else {
                        expectedIndent = getExpectedIndent(trimmedLine);
                    }
                    if (indent !== expectedIndent) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: `Wrong indentation. Expected ${expectedIndent} spaces, got ${indent}.`,
                            severity: "warning"
                        });
                    }
                }

                // Check Feature structure
                if (trimmedLine.startsWith('Feature:')) {
                    if (inFeature) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "Multiple Feature definitions found",
                            severity: "error"
                        });
                    }
                    inFeature = true;
                }

                // Check Background
                if (trimmedLine.startsWith('Background:')) {
                    if (hasBackground) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "Multiple Background sections found",
                            severity: "error"
                        });
                    }
                    if (inScenario) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "Background must be before any Scenario",
                            severity: "error"
                        });
                    }
                    hasBackground = true;
                }

                // Check step order
                const stepMatch = trimmedLine.match(/^(Given|When|Then|And|But|\*)\s/);
                if (stepMatch) {
                    const currentStep = stepMatch[1];
                    if (currentStep === 'When' && lastStepType === 'Then') {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "When steps should come before Then steps",
                            severity: "warning"
                        });
                    }
                    if (currentStep !== 'And' && currentStep !== 'But') {
                        lastStepType = currentStep;
                    }
                }

                // Check for empty scenarios
                if (trimmedLine.match(/^Scenario:|^Scenario Outline:/)) {
                    inScenario = true;
                    const nextLine = lines[i + 1];
                    if (!nextLine || !nextLine.trim().match(/^(Given|When|Then|And|But|\*)\s/)) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "Scenario has no steps",
                            severity: "error"
                        });
                    }
                }

                // Check table format (spacing)
                if (trimmedLine.startsWith('|')) {
                    const cells = trimmedLine.split('|').filter(cell => cell.trim());
                    // Only flag cells with more than one leading space
                    if (!cells.every(cell => cell.length === 0 || cell[0] !== ' ' || (cell.length > 1 && cell[0] === ' ' && cell[1] !== ' '))) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "Table cells should not have more than one leading space",
                            severity: "warning"
                        });
                    }
                }
            });

            if (!inFeature) {
                found.push({
                    from: CodeMirror.Pos(0, 0),
                    to: CodeMirror.Pos(0, lines[0].length),
                    message: "Feature definition missing",
                    severity: "error"
                });
            }

            // Sort so errors appear first
            found.sort((a, b) => {
                if (a.severity === b.severity) return 0;
                if (a.severity === "error") return -1;
                if (b.severity === "error") return 1;
                return 0;
            });

            // Get CodeMirror instance from the current document
            const cmInstances = document.querySelectorAll('.CodeMirror');
            cmInstances.forEach(wrapper => {
                wrapper.classList.remove('has-errors', 'has-warnings', 'is-valid');
                
                const cm = wrapper.CodeMirror;
                if (!cm || !cm.getValue().trim()) return;
                
                if (found.length > 0) {
                    const hasErrors = found.some(issue => issue.severity === 'error');
                    const hasWarnings = found.some(issue => issue.severity === 'warning');
                    
                    if (hasErrors) {
                        wrapper.classList.add('has-errors');
                    } else if (hasWarnings) {
                        wrapper.classList.add('has-warnings');
                    }
                } else {
                    wrapper.classList.add('is-valid');
                }
            });

            return found;
        });

        function getExpectedIndent(line) {
            if (line.startsWith('@') || 
                line.startsWith('Feature:') || 
                line.match(/^(As|I want|So that)/)) {
                return INDENT_CONFIG.TOP_LEVEL_KEYWORDS;
            }
            if (line.match(/^(Background:|Scenario:|Scenario Outline:)/)) {
                return INDENT_CONFIG.TOP_LEVEL_KEYWORDS;
            }
            if (line.match(/^Given\s/)) {
                return INDENT_CONFIG.GIVEN;
            }
            if (line.match(/^(When|Then)\s/)) {
                return INDENT_CONFIG.WHEN_THEN;
            }
            if (line.match(/^(And|But|\*)\s/)) {
                return INDENT_CONFIG.AND_BUT;
            }
            if (line.startsWith('|')) {
                return INDENT_CONFIG.TABLE;
            }
            if (line.startsWith('"""')) {
                return INDENT_CONFIG.DOC_STRING;
            }
            if (line.startsWith('#')) {
                return INDENT_CONFIG.COMMENT;
            }
            if (line.startsWith('Examples:')) {
                return INDENT_CONFIG.EXAMPLES;
            }
            return INDENT_CONFIG.NONE;
        }

        let isFormatted = false;

        // Function to format the editor content
        function formatEditor(e) {
            // Prevent default browser behavior if called from keyboard shortcut
            if (e && e.preventDefault) {
                e.preventDefault();
            }
            
            const formatted = formatGherkin(editor.getValue());
            editor.setValue(formatted);
            isFormatted = true;
            updateCopyButtons(true);
            const formatButton = document.querySelector('.format-button');
            showTooltip(formatButton, 'Code formatted!');
            
            // Return false to prevent default browser behavior
            return false;
        }

        // Function to clear the editor content
        function clearEditor() {
            editor.setValue("");
            isFormatted = false;
            updateCopyButtons(false);
            const clearButton = document.querySelector('.clear-button');
            showTooltip(clearButton, 'Editor cleared!');
        }

        // Function to show tooltip
        function showTooltip(button, message) {
            // Remove any existing tooltips
            const existingTooltip = document.querySelector('.tooltip');
            if (existingTooltip) {
                existingTooltip.remove();
            }

            // Create the tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.textContent = message;
            
            // Add tooltip to the button container
            const buttonContainer = document.querySelector('.button-container');
            buttonContainer.appendChild(tooltip);
            
            // Trigger reflow and add show class
            tooltip.offsetHeight;
            tooltip.classList.add('show');
            
            // Remove tooltip after delay
            setTimeout(() => {
                tooltip.classList.remove('show');
                setTimeout(() => tooltip.remove(), 300);
            }, 3000);
        }

        // Function to copy formatted content
        async function copyToClipboard() {
            try {
                await navigator.clipboard.writeText(editor.getValue());
                const copyButton = document.querySelector('.copy-button');
                showTooltip(copyButton, 'Copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                const copyButton = document.querySelector('.copy-button');
                showTooltip(copyButton, 'Failed to copy!');
            }
        }

        // Function to update copy buttons state
        function updateCopyButtons(enable) {
            const copyButtons = document.querySelectorAll('.copy-button');
            copyButtons.forEach(button => {
                button.disabled = !enable;
            });
        }

        // Theme toggle functionality
        function toggleTheme() {
            const body = document.body;
            const themeButton = document.querySelector('.theme-toggle');
            const isDark = body.classList.toggle('dark-theme');
            
            // Update button icon
            themeButton.textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
            themeButton.title = isDark ? 'Switch to light theme' : 'Switch to zen theme';

            // Save preference
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }

        // Initialize theme from saved preference
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            const themeButton = document.querySelector('.theme-toggle');
            
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-theme');
                themeButton.textContent = 'üåô';
                themeButton.title = 'Switch to light theme';
            } else {
                document.body.classList.remove('dark-theme');
                themeButton.textContent = '‚òÄÔ∏è';
                themeButton.title = 'Switch to zen theme';
            }
            
            // Always set editor theme to cobalt
            if (editor) {
                editor.setOption('theme', 'cobalt');
            }
        }

        // Add click handler to theme toggle button
        document.querySelector('.theme-toggle').addEventListener('click', toggleTheme);

        // Initialize CodeMirror
        var editor = CodeMirror.fromTextArea(document.getElementById("editor"), {
            mode: "gherkin",
            theme: "cobalt",
            lineNumbers: true,
            lineWrapping: true,
            indentUnit: 2,
            tabSize: 2,
            autofocus: true,
            indentWithTabs: false,
            smartIndent: true,
            lint: true,
            extraKeys: {
                "Tab": function(cm) {
                    if (cm.somethingSelected()) {
                        cm.indentSelection("add");
                    } else {
                        var spaces = Array(cm.getOption("indentUnit") + 1).join(" ");
                        cm.replaceSelection(spaces);
                    }
                },
                // Format shortcuts
                "Shift-Ctrl-F": function(cm) {  // Windows
                    formatEditor();
                    return false;  // Prevent default browser find
                },
                "Shift-Cmd-F": function(cm) {   // Mac
                    formatEditor();
                    return false;  // Prevent default browser find
                },
                // Clear shortcuts
                "Ctrl-D": function(cm) {  // Windows
                    cm.setValue("");
                    return false;
                },
                "Cmd-D": function(cm) {    // Mac
                    cm.setValue("");
                    return false;
                },
                // No copy shortcuts - removed
            },
            // Add change handler to detect user edits
            onChange: function(cm) {
                isFormatted = false;
                updateCopyButtons(cm.getValue().trim() !== "");
                
                // Trigger lint to update validation state
                cm.performLint();
            }
        });

        // Add comprehensive Gherkin example with exact alignment
        // Initialize theme
        initializeTheme();

        editor.setValue(`@shopping @regression
Feature: Online Shopping Experience
As an online shopper
I want to browse and purchase items
So that I can conveniently shop from home

@setup
Background: User is logged in
  Given I am on the shopping website
    And I am logged in as "john.doe@example.com"
    And my shopping cart is empty

@search
Scenario: Search for products
   When I search for "laptop"
   Then I should see search results
    And each result should contain:
    | Title       | 
    | Description | 
    | Price       | 
    | Rating      | 

@cart
Scenario: Add item to shopping cart
  Given I am viewing a product "MacBook Pro"
   When I click "Add to Cart" button
   Then the item should be added to my cart
    And the cart count should be 1
      * the cart total should be updated

@checkout @payment
Scenario Outline: Complete purchase with different payment methods
  Given I have "<items>" in my cart
    And the total amount is $"<amount>"
   When I proceed to checkout
    And I select payment method "<payment_method>"
    And I enter following billing details:
    | Field   | Value           | 
    | Name    | John Doe        | 
    | Address | 123 Test Street | 
    | City    | Test City       | 
    | ZIP     | 12345           | 
    | Country | Test Country    | 
   Then I should see order confirmation
    And I should receive an email at "john.doe@example.com"

  Examples: 
    | items          | amount  | payment_method | 
    | Laptop         | 1299.99 | Credit Card    | 
    | Phone, Charger | 899.99  | PayPal         | 
    | Headphones     | 199.99  | Debit Card     | 

@returns
Scenario: Initiate return for purchased item
  Given I have an order "#12345"
   When I request a return
    # This line is a comment explaining the return reason
    And I provide the return reason:
    """
    Product does not meet expectations.
    - Screen has dead pixels
    - Battery life is less than advertised
    - Charging port is loose
    """
   Then a return label should be generated
    And refund should be initiated within 24 hours`);
    </script>
</body>
</html>