<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Free online Gherkin editor with real-time formatting, validation, and linting. Perfect for BDD (Behavior Driven Development) with Cucumber, JBehave, and SpecFlow.">
    <meta name="keywords" content="Gherkin, Cucumber, BDD, Behavior Driven Development, JBehave, SpecFlow, Feature Files, Given When Then, Scenario Outline, Test Automation, Acceptance Testing, ATDD">
    <meta name="author" content="GivenWhenZen">
    <meta property="og:title" content="GivenWhenZen - Online Gherkin Editor & Validator">
    <meta property="og:description" content="Free online Gherkin editor for BDD practitioners. Format, validate, and lint your feature files in real-time.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="GivenWhenZen - Gherkin Editor & BDD Tool">
    <meta name="twitter:description" content="Free online Gherkin editor for Cucumber, JBehave, and SpecFlow. Perfect for BDD practitioners.">
    <title>GivenWhenZen - Online Gherkin Editor, Formatter & BDD Tool</title>
    <link rel="icon" type="image/png" href="favicon1.png">
    <link rel="canonical" href="https://givenwhenzen.com">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <link rel="alternate" hreflang="en" href="https://givenwhenzen.com">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "GivenWhenZen - Online Gherkin Editor",
      "url": "https://givenwhenzen.com",
      "applicationCategory": "DeveloperApplication",
      "operatingSystem": "All",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "Free online Gherkin editor with real-time formatting, validation, and linting for BDD (Behavior Driven Development). Compatible with Cucumber, JBehave, and SpecFlow.",
      "browserRequirements": "Requires a modern web browser",
      "softwareVersion": "1.0.0",
      "keywords": "Gherkin, Cucumber, BDD, Behavior Driven Development, JBehave, SpecFlow, Feature Files",
      "creator": {
        "@type": "Person",
        "name": "Kushal Bhalaik"
      }
    }
    </script>

    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/gherkin/gherkin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/lint.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.7/beautify.min.js"></script>
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/cobalt.min.css">
    
    <!-- Add Lint CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/lint.css">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Consolas', monospace;
            background-color: #f5f5f5;
            transition: background-color 0.3s ease;
        }
        body.dark-theme {
            background-color: #002b36;
        }
        body.dark-theme .editor-container h3 {
            color: #93a1a1;
        }
        body.dark-theme .shortcuts {
            color: #586e75;
        }
        .banner {
            background-color: #002b36;
            color: white;
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .banner-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .banner-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            transition: opacity 0.2s ease;
        }
        .logo:hover {
            opacity: 0.9;
        }
        .logo img {
            height: 32px;
            width: 32px;
            object-fit: contain;
        }
        .logo-text {
            font-size: 24px;
            font-weight: bold;
            color: #2aa198;
            transition: color 0.2s ease;
        }
        .logo:hover .logo-text {
            color: #3eb8af;
        }
        .subtitle {
            color: #93a1a1;
            font-size: 14px;
        }
        .theme-toggle {
            background: none;
            border: none;
            color: #93a1a1;
            cursor: pointer;
            font-size: 20px;
            padding: 4px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .theme-toggle:hover {
            background-color: rgba(255,255,255,0.1);
        }
        .editor-container {
            max-width: 1000px;
            padding: 2%;
            margin: 0 auto;
            position: relative;  /* For absolute positioning of button container */
            padding-top: 1rem;
        }
        .editor-container h3 {
            margin-top: 0;
            color: #002b36;
            font-size: 1rem;
        }
        .CodeMirror {
            height: 600px;
            border: 1px solid #0a3a4a;
            font-size: 14px;
            font-family: 'Consolas', monospace;
        }
        .shortcuts {
            margin-top: 10px;
            color: #93a1a1;
            font-size: 12px;
            border: 1px solid #082830;
            border-radius: 1rem;
        }
        /* Custom styling for Gherkin elements */
        .cm-keyword {
            color: #b58900 !important;
        }
        .cm-variable {
            color: #859900 !important;
        }
        .cm-string {
            color: #2aa198 !important;
        }
        .cm-comment {
            color: #586e75 !important;
        }
        .CodeMirror-linenumber {
            color: #586e75 !important;
        }
        .cm-tab {
            background-color: rgba(255,255,255,0.1);
        }
    
    .bottom {
        text-align: center;
        padding: 2rem;
        margin-top: 2rem;
        color: #586e75;
        margin-bottom: 100px;
    }
    .bottom p {
        margin: 0.5rem 0;
        font-size: 14px;
    }
    .bottom a {
        color: #2aa198;
        text-decoration: none;
        transition: color 0.3s ease;
    }
    .bottom a:hover {
        color: #268bd2;
    }
    .bottom .love-emoji {
        color: #dc322f;
        display: inline-block;
        transform: scale(1);
        transition: transform 0.3s ease;
    }
    .bottom a:hover .love-emoji {
        transform: scale(1.2);
    }
    .bottom .copyright {
        margin-top: 1rem;
        font-size: 12px;
        opacity: 0.8;
    }
    .shortcuts h2{
        font-size: 1rem;
    }
    .bottom .shortcuts {
        margin-bottom: 2rem;
    }
    .bottom .shortcuts ul {
        list-style: none;
        padding: 0;
        margin: 0.5rem 0;
    }
    .bottom .shortcuts li {
        margin: 0.3rem 0;
    }
    body.dark-theme .bottom {
        color: #93a1a1;
    }
    body.dark-theme .bottom a {
        color: #2aa198;
    }
    body.dark-theme .bottom a:hover {
        color: #268bd2;
    }
        /* Button Container */
        .button-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(215, 225, 229, 0.95);
            padding: 1rem;
            border-radius: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 1rem;
            transition: background-color 0.3s ease;
        }
        body.dark-theme .button-container {
            background: rgba(0, 43, 54, 0.95);
        }
        .action-button {
            padding: 8px 16px;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        .format-button {
            background-color: #056d31;
        }
        .format-button:hover {
            background-color: #27ae60;
            transform: translateY(-1px);
        }
        .format-button:active {
            background-color: #219a52;
            transform: translateY(1px);
        }

        .copy-button {
            background-color: #082830;
        }
        .copy-button:hover {
            background-color: #2980b9;
            transform: translateY(-1px);
        }
        .copy-button:active {
            background-color: #2472a4;
            transform: translateY(1px);
        }
        .copy-button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .clear-button {
            background-color: #082830;
        }
        .clear-button:hover {
            background-color: #c0392b;
            transform: translateY(-1px);
        }
        .clear-button:active {
            background-color: #a93226;
            transform: translateY(1px);
        }

        /* Tooltip styles */
        .tooltip {
            position: absolute;
            left: 50%;
            bottom: 100%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            transition: opacity 0.3s ease;
            opacity: 0;
            white-space: nowrap;
            margin-bottom: 8px;
            z-index: 1001;
        }
        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 4px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.8) transparent transparent transparent;
        }
        .tooltip.show {
            opacity: 1;
        }

    </style>
</head>
<body>
    <div class="banner">
        <div class="banner-left">
            <a href="/" class="logo" title="Go to Homepage">
                <img src="favicon.png" alt="GivenWhenZen Logo">
                <span class="logo-text">{ GivenWhenZen }</span>
            </a>
            <span class="subtitle">Online Gherkin Editor and Formatter</span>
        </div>
        <div class="banner-right">
            <button class="theme-toggle" title="Switch to dark theme">☀️</button>
        </div>
    </div>
    <div class="editor-container">
        <h3>Format, validate and lint your Gherkin feature files, just paste it below:</h3>
        <textarea id="editor"></textarea>
    </div>
    <div class="button-container">
        <button onclick="formatEditor()" class="action-button format-button">Format (Ctrl+Shift+F)</button>
        <button onclick="clearEditor()" class="action-button clear-button">Clear (Ctrl+D)</button>
        <button onclick="copyToClipboard()" class="action-button copy-button" disabled>Copy (Ctrl+Shift+C)</button>
    </div>
    <div class="bottom">
        <div class="shortcuts">
            <h2>Shortcuts:</h2>
            <ul>
                <li>Format: Ctrl+Shift+F (Windows) / Cmd+Shift+F (Mac)</li>
                <li>Clear: Ctrl+D (Windows) / Cmd+D (Mac)</li>
                <li>Copy: Ctrl+Shift+C (Windows) / Cmd+Shift+C (Mac)</li>
            </ul>
        </div>
        <p>
            <a href="https://www.kushalbhalaik.xyz/" target="_blank" rel="noopener noreferrer">
                Made with <span class="love-emoji">💙</span> in Berlin
            </a>
        </p>
        <p class="copyright">© 2025 GivenWhenZen.</p>
    </div>
    <script>
        // Global indentation configuration
        const INDENT_CONFIG = {
            TOP_LEVEL_KEYWORDS: 0,          // For Feature, Background, Scenario, Scenario outline, tags, etc.
            GIVEN: 2,        // For Given steps
            WHEN_THEN: 3,    // For When/Then steps
            AND_BUT: 4,      // For And/But/* steps
            TABLE: 6,        // For data tables
            EXAMPLES: 2,     // For Examples section
            DOC_STRING: 6,   // For doc strings
            COMMENT: 2,      // For comments
            NONE: 0,         // For nothing
        };

        // Function to format Gherkin code
        function formatGherkin(code) {
            const lines = code.split('\n');
            let inDocString = false;
            // Table block tracking
            let tableBlocks = [];
            let currentTable = null;

            // First pass: identify table blocks and calculate column widths per table
            lines.forEach((line, index) => {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('|')) {
                    if (!currentTable) {
                        currentTable = { start: index, end: index, rows: [] };
                    }
                    const cells = trimmedLine.split('|')
                        .map(cell => cell.trim())
                        .filter(cell => cell !== '');
                    currentTable.rows.push(cells);
                    currentTable.end = index;
                } else {
                    if (currentTable) {
                        tableBlocks.push(currentTable);
                        currentTable = null;
                    }
                }
            });
            if (currentTable) {
                tableBlocks.push(currentTable);
            }

            // For each table block, calculate max column widths
            tableBlocks.forEach(table => {
                table.maxColumnWidths = [];
                table.rows.forEach(row => {
                    row.forEach((cell, colIndex) => {
                        table.maxColumnWidths[colIndex] = Math.max(table.maxColumnWidths[colIndex] || 0, cell.length);
                    });
                });
            });

            // Second pass: format lines
            const formattedLines = [];
            let tableBlockIdx = 0;
            let insideTable = false;
            let currentTableBlock = null;
            for (let index = 0; index < lines.length; index++) {
                let line = lines[index];
                let formattedLine = line.trimRight(); // Keep trailing spaces

                // Handle empty lines
                if (!formattedLine.trim()) {
                    formattedLines.push('');
                    continue;
                }

                // TOP_LEVEL_KEYWORDS indentation
                if (
                    formattedLine.trim().startsWith('@') ||
                    formattedLine.trim().startsWith('Feature:') ||
                    formattedLine.trim().startsWith('As ') ||
                    formattedLine.trim().startsWith('I want ') ||
                    formattedLine.trim().startsWith('So that ')) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.TOP_LEVEL_KEYWORDS) + formattedLine.trim());
                    continue;
                }

                // Background and Scenario - TOP_LEVEL_KEYWORDS indentation
                if (formattedLine.trim().startsWith('Background:') ||
                    formattedLine.trim().startsWith('Scenario:') ||
                    formattedLine.trim().startsWith('Scenario Outline:')) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.TOP_LEVEL_KEYWORDS) + formattedLine.trim());
                    continue;
                }

                // Given steps
                if (formattedLine.match(/^\s*(Given)/)) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.GIVEN) + formattedLine.trim());
                    continue;
                }

                // When/Then steps
                if (formattedLine.match(/^\s*(When|Then)/)) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.WHEN_THEN) + formattedLine.trim());
                    continue;
                }

                // And/But/* steps
                if (formattedLine.match(/^\s*(And|But|\*)/)) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.AND_BUT) + formattedLine.trim());
                    continue;
                }

                // Tables - with vertical pipe alignment, per-table
                if (formattedLine.trim().startsWith('|')) {
                    // Find which table block this line belongs to
                    if (!insideTable) {
                        // Find the table block that starts at this line
                        for (let tb = tableBlockIdx; tb < tableBlocks.length; tb++) {
                            if (tableBlocks[tb].start <= index && tableBlocks[tb].end >= index) {
                                currentTableBlock = tableBlocks[tb];
                                tableBlockIdx = tb;
                                insideTable = true;
                                break;
                            }
                        }
                    }
                    const cells = formattedLine.trim().split('|')
                        .map(cell => cell.trim())
                        .filter(cell => cell !== '');
                    // Apply consistent padding based on current table's max column widths
                    const paddedCells = cells.map((cell, idx) => {
                        const width = currentTableBlock ? currentTableBlock.maxColumnWidths[idx] || 0 : cell.length;
                        return cell.padEnd(width, ' ');
                    });
                    formattedLines.push(' '.repeat(INDENT_CONFIG.TABLE) + '| ' + paddedCells.join(' | ') + ' |');
                    // If this is the last line of the table block, reset
                    if (currentTableBlock && index === currentTableBlock.end) {
                        insideTable = false;
                        currentTableBlock = null;
                        tableBlockIdx++;
                    }
                    continue;
                }

                // Doc strings
                if (formattedLine.trim().startsWith('"""')) {
                    inDocString = !inDocString; // Toggle doc string state
                    formattedLines.push(' '.repeat(INDENT_CONFIG.DOC_STRING) + formattedLine.trim());
                    continue;
                }
                // Content inside doc string
                if (inDocString) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.DOC_STRING) + formattedLine.trim());
                    continue;
                }

                // Comments
                if (formattedLine.trim().startsWith('#')) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.COMMENT) + formattedLine.trim());
                    continue;
                }

                // Examples section
                if (formattedLine.trim().startsWith('Examples:')) {
                    formattedLines.push(' '.repeat(INDENT_CONFIG.EXAMPLES) + formattedLine.trim());
                    continue;
                }

                formattedLines.push(formattedLine);
            }

            return formattedLines.join('\n');
        }

        // Gherkin Lint function
        CodeMirror.registerHelper("lint", "gherkin", function(text) {
            const found = [];
            const lines = text.split('\n');
            let inFeature = false;
            let inScenario = false;
            let lastStepType = null;
            let hasBackground = false;

            // Table block tracking for column count validation
            let tableBlocks = [];
            let currentTable = null;
            lines.forEach((line, index) => {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('|')) {
                    if (!currentTable) {
                        currentTable = { start: index, end: index, rows: [] };
                    }
                    const cells = trimmedLine.split('|')
                        .map(cell => cell.trim())
                        .filter(cell => cell !== '');
                    currentTable.rows.push({ cells, lineIndex: index });
                    currentTable.end = index;
                } else {
                    if (currentTable) {
                        tableBlocks.push(currentTable);
                        currentTable = null;
                    }
                }
            });
            if (currentTable) {
                tableBlocks.push(currentTable);
            }

            // Validate column count for each table block
            tableBlocks.forEach(table => {
                // Find expected column count (most common count or max count)
                const colCounts = table.rows.map(r => r.cells.length);
                // Use max count as expected
                const expectedColCount = Math.max(...colCounts);
                table.rows.forEach(row => {
                    if (row.cells.length !== expectedColCount) {
                        found.push({
                            from: CodeMirror.Pos(row.lineIndex, 0),
                            to: CodeMirror.Pos(row.lineIndex, lines[row.lineIndex].length),
                            message: `Table row has ${row.cells.length} columns, expected ${expectedColCount}.`,
                            severity: "error"
                        });
                    }
                });
            });

            lines.forEach((line, i) => {
                const trimmedLine = line.trim();
                // Track docstring state
                if (!lines._inDocString) lines._inDocString = false;
                if (trimmedLine.startsWith('"""')) {
                    lines._inDocString = !lines._inDocString;
                }

                // Check indentation
                if (trimmedLine) {
                    const indent = line.match(/^(\s*)/)[1].length;
                    let expectedIndent;
                    if (lines._inDocString && !trimmedLine.startsWith('"""')) {
                        expectedIndent = INDENT_CONFIG.DOC_STRING;
                    } else {
                        expectedIndent = getExpectedIndent(trimmedLine);
                    }
                    if (indent !== expectedIndent) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: `Wrong indentation. Expected ${expectedIndent} spaces, got ${indent}.`,
                            severity: "warning"
                        });
                    }
                }

                // Check Feature structure
                if (trimmedLine.startsWith('Feature:')) {
                    if (inFeature) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "Multiple Feature definitions found",
                            severity: "error"
                        });
                    }
                    inFeature = true;
                }

                // Check Background
                if (trimmedLine.startsWith('Background:')) {
                    if (hasBackground) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "Multiple Background sections found",
                            severity: "error"
                        });
                    }
                    if (inScenario) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "Background must be before any Scenario",
                            severity: "error"
                        });
                    }
                    hasBackground = true;
                }

                // Check step order
                const stepMatch = trimmedLine.match(/^(Given|When|Then|And|But|\*)\s/);
                if (stepMatch) {
                    const currentStep = stepMatch[1];
                    if (currentStep === 'When' && lastStepType === 'Then') {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "When steps should come before Then steps",
                            severity: "warning"
                        });
                    }
                    if (currentStep !== 'And' && currentStep !== 'But') {
                        lastStepType = currentStep;
                    }
                }

                // Check for empty scenarios
                if (trimmedLine.match(/^Scenario:|^Scenario Outline:/)) {
                    inScenario = true;
                    const nextLine = lines[i + 1];
                    if (!nextLine || !nextLine.trim().match(/^(Given|When|Then|And|But|\*)\s/)) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "Scenario has no steps",
                            severity: "error"
                        });
                    }
                }

                // Check table format (spacing)
                if (trimmedLine.startsWith('|')) {
                    const cells = trimmedLine.split('|').filter(cell => cell.trim());
                    // Only flag cells with more than one leading space
                    if (!cells.every(cell => cell.length === 0 || cell[0] !== ' ' || (cell.length > 1 && cell[0] === ' ' && cell[1] !== ' '))) {
                        found.push({
                            from: CodeMirror.Pos(i, 0),
                            to: CodeMirror.Pos(i, line.length),
                            message: "Table cells should not have more than one leading space",
                            severity: "warning"
                        });
                    }
                }
            });

            if (!inFeature) {
                found.push({
                    from: CodeMirror.Pos(0, 0),
                    to: CodeMirror.Pos(0, lines[0].length),
                    message: "Feature definition missing",
                    severity: "error"
                });
            }

            // Sort so errors appear first
            found.sort((a, b) => {
                if (a.severity === b.severity) return 0;
                if (a.severity === "error") return -1;
                if (b.severity === "error") return 1;
                return 0;
            });
            return found;
        });

        function getExpectedIndent(line) {
            if (line.startsWith('@') || 
                line.startsWith('Feature:') || 
                line.match(/^(As|I want|So that)/)) {
                return INDENT_CONFIG.TOP_LEVEL_KEYWORDS;
            }
            if (line.match(/^(Background:|Scenario:|Scenario Outline:)/)) {
                return INDENT_CONFIG.TOP_LEVEL_KEYWORDS;
            }
            if (line.match(/^Given\s/)) {
                return INDENT_CONFIG.GIVEN;
            }
            if (line.match(/^(When|Then)\s/)) {
                return INDENT_CONFIG.WHEN_THEN;
            }
            if (line.match(/^(And|But|\*)\s/)) {
                return INDENT_CONFIG.AND_BUT;
            }
            if (line.startsWith('|')) {
                return INDENT_CONFIG.TABLE;
            }
            if (line.startsWith('"""')) {
                return INDENT_CONFIG.DOC_STRING;
            }
            if (line.startsWith('#')) {
                return INDENT_CONFIG.COMMENT;
            }
            if (line.startsWith('Examples:')) {
                return INDENT_CONFIG.EXAMPLES;
            }
            return INDENT_CONFIG.NONE;
        }

        let isFormatted = false;

        // Function to format the editor content
        function formatEditor() {
            const formatted = formatGherkin(editor.getValue());
            editor.setValue(formatted);
            isFormatted = true;
            updateCopyButtons(true);
            const formatButton = document.querySelector('.format-button');
            showTooltip(formatButton, 'Code formatted!');
        }

        // Function to clear the editor content
        function clearEditor() {
            editor.setValue("");
            isFormatted = false;
            updateCopyButtons(false);
            const clearButton = document.querySelector('.clear-button');
            showTooltip(clearButton, 'Editor cleared!');
        }

        // Function to show tooltip
        function showTooltip(button, message) {
            // Remove any existing tooltips
            const existingTooltip = document.querySelector('.tooltip');
            if (existingTooltip) {
                existingTooltip.remove();
            }

            // Create the tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.textContent = message;
            
            // Add tooltip to the button container
            const buttonContainer = document.querySelector('.button-container');
            buttonContainer.appendChild(tooltip);
            
            // Trigger reflow and add show class
            tooltip.offsetHeight;
            tooltip.classList.add('show');
            
            // Remove tooltip after delay
            setTimeout(() => {
                tooltip.classList.remove('show');
                setTimeout(() => tooltip.remove(), 300);
            }, 3000);
        }

        // Function to copy formatted content
        async function copyToClipboard() {
            try {
                await navigator.clipboard.writeText(editor.getValue());
                const copyButton = document.querySelector('.copy-button');
                showTooltip(copyButton, 'Copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                const copyButton = document.querySelector('.copy-button');
                showTooltip(copyButton, 'Failed to copy!');
            }
        }

        // Function to update copy buttons state
        function updateCopyButtons(enable) {
            const copyButtons = document.querySelectorAll('.copy-button');
            copyButtons.forEach(button => {
                button.disabled = !enable;
            });
        }

        // Theme toggle functionality
        function toggleTheme() {
            const body = document.body;
            const themeButton = document.querySelector('.theme-toggle');
            const isDark = body.classList.toggle('dark-theme');
            
            // Update button icon
            themeButton.textContent = isDark ? '🌙' : '☀️';
            themeButton.title = isDark ? 'Switch to light theme' : 'Switch to dark theme';

            // Save preference
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }

        // Initialize theme from saved preference
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            const themeButton = document.querySelector('.theme-toggle');
            
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-theme');
                themeButton.textContent = '🌙';
                themeButton.title = 'Switch to light theme';
            } else {
                document.body.classList.remove('dark-theme');
                themeButton.textContent = '☀️';
                themeButton.title = 'Switch to dark theme';
            }
            
            // Always set editor theme to cobalt
            if (editor) {
                editor.setOption('theme', 'cobalt');
            }
        }

        // Add click handler to theme toggle button
        document.querySelector('.theme-toggle').addEventListener('click', toggleTheme);

        // Initialize CodeMirror
        var editor = CodeMirror.fromTextArea(document.getElementById("editor"), {
            mode: "gherkin",
            theme: "cobalt",
            lineNumbers: true,
            lineWrapping: true,
            indentUnit: 2,
            tabSize: 2,
            autofocus: true,
            indentWithTabs: false,
            smartIndent: true,
            lint: true,
            extraKeys: {
                "Tab": function(cm) {
                    if (cm.somethingSelected()) {
                        cm.indentSelection("add");
                    } else {
                        var spaces = Array(cm.getOption("indentUnit") + 1).join(" ");
                        cm.replaceSelection(spaces);
                    }
                },
                // Format shortcuts
                "Ctrl-Shift-F": function(cm) {  // Windows
                    const formatted = formatGherkin(cm.getValue());
                    editor.setValue(formatted);
                    return false;  // Prevent default browser find
                },
                "Cmd-Shift-F": function(cm) {   // Mac
                    const formatted = formatGherkin(cm.getValue());
                    editor.setValue(formatted);
                    return false;  // Prevent default browser find
                },
                // Clear shortcuts
                "Ctrl-D": function(cm) {  // Windows
                    cm.setValue("");
                    return false;
                },
                "Cmd-D": function(cm) {    // Mac
                    cm.setValue("");
                    return false;
                },
                // Copy shortcuts
                "Ctrl-Shift-C": function(cm) {  // Windows
                    if (!cm.getValue() || cm.getValue().trim() === "") return;
                    copyToClipboard();
                    return false;
                },
                "Cmd-Shift-C": function(cm) {   // Mac
                    if (!cm.getValue() || cm.getValue().trim() === "") return;
                    copyToClipboard();
                    return false;
                }
            },
            // Add change handler to detect user edits
            onChange: function(cm) {
                isFormatted = false;
                updateCopyButtons(cm.getValue().trim() !== "");
            }
        });

        // Add comprehensive Gherkin example with exact alignment
        // Initialize theme
        initializeTheme();

        editor.setValue(`@shopping @regression
Feature: Online Shopping Experience
As an online shopper
I want to browse and purchase items
So that I can conveniently shop from home

@setup
Background: User is logged in
  Given I am on the shopping website
    And I am logged in as "john.doe@example.com"
    And my shopping cart is empty

@search
Scenario: Search for products
   When I search for "laptop"
   Then I should see search results
    And each result should contain:
    | Title       | 
    | Description | 
    | Price       | 
    | Rating      | 

@cart
Scenario: Add item to shopping cart
  Given I am viewing a product "MacBook Pro"
   When I click "Add to Cart" button
   Then the item should be added to my cart
    And the cart count should be 1
      * the cart total should be updated

@checkout @payment
Scenario Outline: Complete purchase with different payment methods
  Given I have "<items>" in my cart
    And the total amount is $"<amount>"
   When I proceed to checkout
    And I select payment method "<payment_method>"
    And I enter following billing details:
    | Field   | Value           | 
    | Name    | John Doe        | 
    | Address | 123 Test Street | 
    | City    | Test City       | 
    | ZIP     | 12345           | 
    | Country | Test Country    | 
   Then I should see order confirmation
    And I should receive an email at "john.doe@example.com"

  Examples: 
    | items          | amount  | payment_method | 
    | Laptop         | 1299.99 | Credit Card    | 
    | Phone, Charger | 899.99  | PayPal         | 
    | Headphones     | 199.99  | Debit Card     | 

@returns
Scenario: Initiate return for purchased item
  Given I have an order "#12345"
   When I request a return
    # This line is a comment explaining the return reason
    And I provide the return reason:
    """
    Product does not meet expectations.
    - Screen has dead pixels
    - Battery life is less than advertised
    - Charging port is loose
    """
   Then a return label should be generated
    And refund should be initiated within 24 hours`);
    </script>
</body>
</html>